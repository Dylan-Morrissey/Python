# -*- coding: utf-8 -*-
"""DemoNeuralNetwork.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vgGgkHQeSzbVW247M9uYpPPPd5mdFINm
"""

# Commented out IPython magic to ensure Python compatibility.
try:
  # %tensorflow_version only exists in Colab.
#   %tensorflow_version 2.x
except Exception:
  pass
import tensorflow as tf
from tensorflow import keras
import numpy as np
import matplotlib.pyplot as plt
import os
import cv2
import random

print(tf.__version__)

from google.colab import drive
drive.mount('/content/gdrive')

datadir = "/content/gdrive/My Drive/dataset"
class_names = ['lean', 'notlean']

for category in class_names:  # do lean and notlean
    path = os.path.join(datadir,category)  # create path to lean and notlean
    for img in os.listdir(path):  # iterate over each image per lean and notlean

        img_array = cv2.imread(os.path.join(path,img) ,cv2.IMREAD_GRAYSCALE)  # convert to array
        plt.imshow(img_array, cmap='gray')  # graph it
        plt.show()  # display!

        break  # we just want one for now so break
    break  #...and one more!

IMG_SIZE = 150

new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))
plt.imshow(new_array, cmap='gray')
plt.show()

training_data = []

def create_training_data():
    for category in class_names:  # do lean and notlean

        path = os.path.join(datadir,category)  # create path to lean and notlean
        class_num = class_names.index(category)  # get the classification  (0 or a 1). 0=lean 1=notlean

        for img in (os.listdir(path)):  # iterate over each image per lean and notlean
            try:
                img_array = cv2.imread(os.path.join(path,img) ,cv2.IMREAD_GRAYSCALE)  # convert to array
                new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))  # resize to normalize data size
                training_data.append([new_array, class_num])  # add to  training_data
            except Exception as e:
                pass

create_training_data()
print(len(training_data))

random.shuffle(training_data)
for sample in training_data:
  if(sample[1] == 0):
      print("Lean")
  else:
      print("Not Lean")

X = []
y = []

for features,label in training_data:
    X.append(features)
    y.append(label)
# -1 magic feature number
# 1 For greyscale
X = np.array(X).reshape(-1, IMG_SIZE, IMG_SIZE, 1)
y = np.array(y)

from tensorflow.keras.datasets import cifar10
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten
from tensorflow.keras.layers import Conv2D, MaxPooling2D

X = X/255.0

model = Sequential()

model.add(Conv2D(128, (3, 3), input_shape=X.shape[1:]))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(128, (3, 3)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())  # this converts the 3D feature maps to 1D for dense
model.add(Dense(64))

#Output lay
model.add(Dense(1))
model.add(Activation('sigmoid'))

model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

model.fit(X, y, batch_size=20, epochs=5, validation_split=.05)